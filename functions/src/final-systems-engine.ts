import {onCall, HttpsError} from "firebase-functions/v2/https";
import {onDocumentCreated} from "firebase-functions/v2/firestore";
import {onSchedule} from "firebase-functions/v2/scheduler";
import {logger} from "firebase-functions/v2";
import type {CallableRequest} from "firebase-functions/v2/https";
import * as admin from "firebase-admin";
import {v4 as uuidv4} from "uuid";

// Initialize admin SDK if not already initialized
if (admin.apps.length === 0) {
  admin.initializeApp();
}
const db = admin.firestore();

/**
 * Sections 6-8: Monetization, Onboarding & Compliance Implementation
 * Following the URAI build checklist specifications
 */

// ===== SECTION 6: MONETIZATION & DATA CONTROL =====

/**
 * 1. Insight Marketplace - Anonymized insights API
 */
export const generateAnonymizedInsights = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  const { insightType = 'mood_patterns', timeRange = 30 } = request.data;

  try {
    logger.info(`Generating anonymized insights for user ${uid}, type: ${insightType}`);

    // Check if user has consented to data sharing
    const userDoc = await db.collection("users").doc(uid).get();
    const userData = userDoc.data();
    
    if (!userData?.settings?.dataConsent?.shareAnonymousData) {
      throw new HttpsError("permission-denied", "User has not consented to data sharing");
    }

    // Generate anonymized insights based on type
    const insights = await generateInsightsByType(uid, insightType, timeRange);
    
    // Create anonymized package
    const anonymizedPackage = {
      id: uuidv4(),
      userId: hashUserId(uid), // Anonymized user ID
      insightType: insightType,
      timeRange: timeRange,
      insights: insights,
      anonymizationLevel: 'high',
      generatedAt: Date.now(),
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000, // 30 days
      marketplaceReady: true
    };

    await db.collection("anonymizedInsights").doc(anonymizedPackage.id).set(anonymizedPackage);

    return {
      success: true,
      packageId: anonymizedPackage.id,
      insights: insights,
      potentialValue: calculateInsightValue(insights)
    };
  } catch (error) {
    logger.error("Error generating anonymized insights:", error);
    throw new HttpsError("internal", "Failed to generate anonymized insights");
  }
});

/**
 * 2. Pro Tier Feature Lock
 */
export const checkProTierAccess = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  const { feature } = request.data;

  try {
    logger.info(`Checking pro tier access for user ${uid}, feature: ${feature}`);

    const userDoc = await db.collection("users").doc(uid).get();
    const userData = userDoc.data();
    const isProUser = userData?.isProUser || false;

    const proFeatures = [
      'advanced_analytics',
      'timeline_compare',
      'memory_galaxy_export',
      'therapist_replay_unlimited',
      'custom_narrator_voice',
      'data_export_detailed',
      'premium_seasonal_themes',
      'recovery_anniversary_tracking'
    ];

    const hasAccess = isProUser || !proFeatures.includes(feature);

    return {
      success: true,
      hasAccess: hasAccess,
      isProUser: isProUser,
      feature: feature,
      upgradeRequired: !hasAccess
    };
  } catch (error) {
    logger.error("Error checking pro tier access:", error);
    throw new HttpsError("internal", "Failed to check pro tier access");
  }
});

/**
 * 3. Data Ownership Dashboard
 */
export const getUserDataExport = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  const { format = 'json', includeInsights = true } = request.data;

  try {
    logger.info(`Generating data export for user ${uid}, format: ${format}`);

    // Collect all user data
    const userData = await collectCompleteUserData(uid, includeInsights);
    
    // Create export package
    const exportPackage = {
      id: uuidv4(),
      userId: uid,
      format: format,
      data: userData,
      exportedAt: Date.now(),
      downloadUrl: '', // Would be generated by storage function
      expiresAt: Date.now() + 7 * 24 * 60 * 60 * 1000, // 7 days
      size: JSON.stringify(userData).length
    };

    await db.collection("dataExports").doc(exportPackage.id).set(exportPackage);

    return {
      success: true,
      exportId: exportPackage.id,
      size: exportPackage.size,
      downloadReady: true,
      expiresAt: exportPackage.expiresAt
    };
  } catch (error) {
    logger.error("Error generating data export:", error);
    throw new HttpsError("internal", "Failed to generate data export");
  }
});

// ===== SECTION 7: ONBOARDING & RETENTION =====

/**
 * 1. Guided Onboarding Scroll
 */
export const createOnboardingScroll = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  try {
    logger.info(`Creating onboarding scroll for user ${uid}`);

    const onboardingScroll = {
      id: uuidv4(),
      userId: uid,
      title: "Welcome to Your URAI Journey",
      sections: [
        {
          id: "welcome",
          title: "Your Digital Companion",
          content: "URAI is here to help you understand the patterns of your inner world through gentle observation and insight.",
          narration: "Welcome to a new way of understanding yourself. I'm here to listen, learn, and walk alongside you.",
          visualTheme: "gentle_introduction",
          interactionRequired: false
        },
        {
          id: "data_capture",
          title: "How We Listen",
          content: "With your permission, URAI observes patterns in your voice, movement, and digital behavior to build understanding.",
          narration: "I'll pay attention to the subtle signals that reveal your emotional rhythms and inner states.",
          visualTheme: "data_visualization",
          interactionRequired: true,
          permissions: ["microphone", "motion", "notifications"]
        },
        {
          id: "ai_insights",
          title: "Understanding Together", 
          content: "AI helps identify patterns and insights, but the interpretation is always collaborative between you and URAI.",
          narration: "Think of our AI as a gentle analytical mind that helps us both see patterns you might otherwise miss.",
          visualTheme: "collaborative_analysis",
          interactionRequired: false
        },
        {
          id: "privacy",
          title: "Your Data, Your Choice",
          content: "You maintain complete control over your data, with options to export, share anonymously, or keep everything private.",
          narration: "Your inner world belongs to you. I'm simply a trusted companion who helps you explore it.",
          visualTheme: "privacy_shield", 
          interactionRequired: true,
          settings: ["data_consent", "privacy_level"]
        }
      ],
      progress: 0,
      completed: false,
      createdAt: Date.now(),
      lastAccessedAt: Date.now()
    };

    await db.collection("onboardingScrolls").doc(onboardingScroll.id).set(onboardingScroll);

    return {
      success: true,
      scroll: onboardingScroll
    };
  } catch (error) {
    logger.error("Error creating onboarding scroll:", error);
    throw new HttpsError("internal", "Failed to create onboarding scroll");
  }
});

/**
 * 2. Weekly Summary Emails
 */
export const generateWeeklySummaryEmail = onSchedule(
  {
    schedule: "0 9 * * 1", // Every Monday at 9 AM
    timeZone: "UTC"
  },
  async () => {
    logger.info("Generating weekly summary emails");

    try {
      const usersSnapshot = await db.collection("users")
        .where("settings.receiveWeeklyEmail", "==", true)
        .get();

      for (const userDoc of usersSnapshot.docs) {
        const userId = userDoc.id;
        const userData = userDoc.data();
        
        // Get week's data
        const weekStart = new Date();
        weekStart.setDate(weekStart.getDate() - 7);
        const weekEnd = new Date();

        const weeklyData = await getWeeklyUserData(userId, weekStart, weekEnd);
        
        if (weeklyData.hasSignificantData) {
          const summary = generateWeeklySummary(weeklyData, userData);
          
          const emailData = {
            id: uuidv4(),
            userId: userId,
            type: 'weekly_summary',
            subject: `Your Week in Reflection - ${weekStart.toLocaleDateString()}`,
            content: summary.content,
            narratorScript: summary.narratorScript,
            insights: summary.insights,
            scheduledFor: Date.now(),
            createdAt: Date.now()
          };

          await db.collection("emailQueue").doc(emailData.id).set(emailData);
          
          logger.info(`Weekly summary email queued for user ${userId}`);
        }
      }
    } catch (error) {
      logger.error("Error generating weekly summary emails:", error);
    }
  }
);

/**
 * 3. Monthly Voice Recaps
 */
export const generateMonthlyVoiceRecap = onSchedule(
  {
    schedule: "0 10 1 * *", // First day of month at 10 AM
    timeZone: "UTC"
  },
  async () => {
    logger.info("Generating monthly voice recaps");

    try {
      const usersSnapshot = await db.collection("users")
        .where("settings.receiveMilestones", "==", true)
        .get();

      for (const userDoc of usersSnapshot.docs) {
        const userId = userDoc.id;
        const userData = userDoc.data();
        
        // Get previous month's data
        const now = new Date();
        const monthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        const monthEnd = new Date(now.getFullYear(), now.getMonth(), 0);

        const monthlyData = await getMonthlyUserData(userId, monthStart, monthEnd);
        
        if (monthlyData.hasVoiceData) {
          const voiceRecap = generateMonthlyNarration(monthlyData, userData);
          
          const recapData = {
            id: uuidv4(),
            userId: userId,
            type: 'monthly_voice_recap',
            month: monthStart.toISOString().slice(0, 7), // YYYY-MM
            script: voiceRecap.script,
            highlights: voiceRecap.highlights,
            ttsConfig: userData.narratorPrefs?.ttsConfig || { pitch: 1.0, speed: 1.0 },
            createdAt: Date.now()
          };

          await db.collection("voiceRecaps").doc(recapData.id).set(recapData);
          
          logger.info(`Monthly voice recap generated for user ${userId}`);
        }
      }
    } catch (error) {
      logger.error("Error generating monthly voice recaps:", error);
    }
  }
);

// ===== SECTION 8: COMPLIANCE & LAUNCH PREP =====

/**
 * 1. Privacy & Consent Settings
 */
export const updatePrivacySettings = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  const { settings } = request.data;

  try {
    logger.info(`Updating privacy settings for user ${uid}`);

    // Validate privacy settings
    const validatedSettings = validatePrivacySettings(settings);
    
    // Update user settings
    await db.collection("users").doc(uid).update({
      'settings.dataConsent': validatedSettings.dataConsent,
      'settings.gpsAllowed': validatedSettings.gpsAllowed,
      'settings.allowVoiceRetention': validatedSettings.allowVoiceRetention,
      'settings.telemetryPermissionsGranted': validatedSettings.telemetryPermissionsGranted,
      'settings.cameraCapturePermissionsGranted': validatedSettings.cameraCapturePermissionsGranted,
      'settings.identityModelOptIn': validatedSettings.identityModelOptIn,
      updatedAt: Date.now()
    });

    // Log privacy change for compliance
    const privacyLog = {
      id: uuidv4(),
      userId: uid,
      changeType: 'privacy_settings_update',
      previousSettings: '', // Would be retrieved from audit log
      newSettings: validatedSettings,
      timestamp: Date.now(),
      ipAddress: request.rawRequest?.ip || 'unknown'
    };

    await db.collection("privacyAuditLog").doc(privacyLog.id).set(privacyLog);

    return {
      success: true,
      settings: validatedSettings,
      effectiveDate: Date.now()
    };
  } catch (error) {
    logger.error("Error updating privacy settings:", error);
    throw new HttpsError("internal", "Failed to update privacy settings");
  }
});

/**
 * 2. Full Data Export for Compliance
 */
export const triggerComplianceExport = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  try {
    logger.info(`Triggering compliance data export for user ${uid}`);

    // Create comprehensive export including audit logs
    const complianceData = await collectComplianceData(uid);
    
    const exportRecord = {
      id: uuidv4(),
      userId: uid,
      exportType: 'gdpr_compliance',
      requestedAt: Date.now(),
      data: complianceData,
      status: 'ready',
      downloadUrl: '', // Would be generated
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000 // 30 days
    };

    await db.collection("complianceExports").doc(exportRecord.id).set(exportRecord);

    return {
      success: true,
      exportId: exportRecord.id,
      estimatedSize: JSON.stringify(complianceData).length,
      includesAuditTrail: true
    };
  } catch (error) {
    logger.error("Error triggering compliance export:", error);
    throw new HttpsError("internal", "Failed to trigger compliance export");
  }
});

/**
 * 3. Alpha Testing Framework
 */
export const submitAlphaFeedback = onCall(async (request: CallableRequest) => {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "User must be authenticated.");
  }

  const { category, feedback, rating, attachments } = request.data;

  try {
    logger.info(`Submitting alpha feedback from user ${uid}, category: ${category}`);

    const feedbackRecord = {
      id: uuidv4(),
      userId: uid,
      category: category,
      feedback: feedback,
      rating: rating,
      attachments: attachments || [],
      userAgent: request.rawRequest?.headers['user-agent'] || '',
      timestamp: Date.now(),
      status: 'new',
      priority: calculateFeedbackPriority(category, rating)
    };

    await db.collection("alphaFeedback").doc(feedbackRecord.id).set(feedbackRecord);

    return {
      success: true,
      feedbackId: feedbackRecord.id,
      status: 'submitted'
    };
  } catch (error) {
    logger.error("Error submitting alpha feedback:", error);
    throw new HttpsError("internal", "Failed to submit alpha feedback");
  }
});

// Helper functions
async function generateInsightsByType(userId: string, type: string, timeRange: number): Promise<any> {
  // Generate anonymized insights based on type
  switch (type) {
    case 'mood_patterns':
      return await generateMoodPatternInsights(userId, timeRange);
    case 'recovery_trends':
      return await generateRecoveryTrendInsights(userId, timeRange);
    case 'interaction_patterns':
      return await generateInteractionPatternInsights(userId, timeRange);
    default:
      return { insights: [], summary: 'No insights available for this type' };
  }
}

function hashUserId(userId: string): string {
  // Simple hash for anonymization - in production would use proper crypto
  return `anon_${userId.slice(-8)}`;
}

function calculateInsightValue(insights: any): number {
  // Calculate potential marketplace value
  const baseValue = 0.10; // $0.10 base
  const complexityMultiplier = insights.complexity || 1;
  const uniquenessScore = insights.uniqueness || 1;
  
  return Math.round((baseValue * complexityMultiplier * uniquenessScore) * 100) / 100;
}

async function collectCompleteUserData(userId: string, includeInsights: boolean): Promise<any> {
  const collections = [
    'voiceEvents', 'dreamEvents', 'cognitiveMirror', 'rhythmMap', 
    'healthEcho', 'gpsEvents', 'deviceSignals', 'shadowCognition',
    'obscuraPatterns', 'voiceProfiles'
  ];

  const userData: any = { userId, exportedAt: Date.now(), collections: {} };

  for (const collection of collections) {
    const snapshot = await db.collection(collection)
      .where('userId', '==', userId)
      .get();
    
    userData.collections[collection] = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));
  }

  if (includeInsights) {
    userData.insights = await generateInsightsByType(userId, 'comprehensive', 365);
  }

  return userData;
}

async function getWeeklyUserData(userId: string, weekStart: Date, weekEnd: Date): Promise<any> {
  const cognitiveData = await db.collection("cognitiveMirror")
    .where("userId", "==", userId)
    .where("date", ">=", weekStart.toISOString().split('T')[0])
    .where("date", "<=", weekEnd.toISOString().split('T')[0])
    .get();

  return {
    hasSignificantData: !cognitiveData.empty,
    cognitiveStates: cognitiveData.docs.map(doc => doc.data()),
    weekStart: weekStart.toISOString(),
    weekEnd: weekEnd.toISOString()
  };
}

function generateWeeklySummary(weeklyData: any, userData: any): any {
  const avgMood = weeklyData.cognitiveStates.reduce((sum: number, day: any) => 
    sum + (day.moodScore || 50), 0) / weeklyData.cognitiveStates.length;

  return {
    content: `This week your mood averaged ${avgMood.toFixed(1)} points. ${
      avgMood > 60 ? "You've had a predominantly positive week!" : 
      avgMood < 40 ? "This week presented some challenges." :
      "Your week had a balanced emotional rhythm."
    }`,
    narratorScript: generateWeeklyNarratorScript(weeklyData, avgMood),
    insights: weeklyData.cognitiveStates.flatMap((day: any) => day.highlightInsights || [])
  };
}

function generateWeeklyNarratorScript(weeklyData: any, avgMood: number): string {
  return `Looking back at this week, I've witnessed your journey through ${weeklyData.cognitiveStates.length} days of experiences. ${
    avgMood > 60 ? "Your inner light has been particularly bright, illuminating the path ahead." :
    avgMood < 40 ? "You've navigated some deeper waters, showing quiet strength in the process." :
    "You've maintained a steady rhythm through the week's various movements."
  } Remember, every experience contributes to the larger tapestry of your growth.`;
}

async function getMonthlyUserData(userId: string, monthStart: Date, monthEnd: Date): Promise<any> {
  const voiceEvents = await db.collection("voiceEvents")
    .where("uid", "==", userId)
    .where("createdAt", ">=", monthStart.getTime())
    .where("createdAt", "<=", monthEnd.getTime())
    .get();

  return {
    hasVoiceData: !voiceEvents.empty,
    voiceEvents: voiceEvents.docs.map(doc => doc.data()),
    monthStart: monthStart.toISOString(),
    monthEnd: monthEnd.toISOString()
  };
}

function generateMonthlyNarration(monthlyData: any, userData: any): any {
  const emotionCounts = monthlyData.voiceEvents.reduce((counts: any, event: any) => {
    counts[event.emotion] = (counts[event.emotion] || 0) + 1;
    return counts;
  }, {});

  const dominantEmotion = Object.entries(emotionCounts)
    .reduce((a: any, b: any) => emotionCounts[a[0]] > emotionCounts[b[0]] ? a : b)[0];

  return {
    script: `This month, I've listened to ${monthlyData.voiceEvents.length} moments of your voice. ${dominantEmotion} emerged as a recurring theme in your expressions. Each conversation has added another layer to my understanding of your inner world.`,
    highlights: Object.keys(emotionCounts).slice(0, 3)
  };
}

function validatePrivacySettings(settings: any): any {
  return {
    dataConsent: {
      shareAnonymousData: Boolean(settings.dataConsent?.shareAnonymousData),
      optedOutAt: settings.dataConsent?.shareAnonymousData ? null : Date.now()
    },
    gpsAllowed: Boolean(settings.gpsAllowed),
    allowVoiceRetention: Boolean(settings.allowVoiceRetention),
    telemetryPermissionsGranted: Boolean(settings.telemetryPermissionsGranted),
    cameraCapturePermissionsGranted: Boolean(settings.cameraCapturePermissionsGranted),
    identityModelOptIn: Boolean(settings.identityModelOptIn)
  };
}

async function collectComplianceData(userId: string): Promise<any> {
  const userData = await collectCompleteUserData(userId, false);
  
  // Add compliance-specific data
  const privacyLogs = await db.collection("privacyAuditLog")
    .where("userId", "==", userId)
    .get();

  return {
    ...userData,
    privacyAuditTrail: privacyLogs.docs.map(doc => doc.data()),
    complianceVersion: '1.0',
    exportType: 'gdpr_compliance'
  };
}

function calculateFeedbackPriority(category: string, rating: number): string {
  if (category === 'bug' && rating <= 2) return 'high';
  if (category === 'feature_request' && rating >= 4) return 'medium';
  return 'low';
}

async function generateMoodPatternInsights(userId: string, timeRange: number): Promise<any> {
  // Anonymized mood pattern analysis
  return {
    insights: ['Weekly mood cycles detected', 'Stress recovery patterns identified'],
    complexity: 2.5,
    uniqueness: 1.8
  };
}

async function generateRecoveryTrendInsights(userId: string, timeRange: number): Promise<any> {
  return {
    insights: ['Recovery acceleration patterns', 'Resilience building trends'],
    complexity: 3.0,
    uniqueness: 2.1
  };
}

async function generateInteractionPatternInsights(userId: string, timeRange: number): Promise<any> {
  return {
    insights: ['Communication rhythm analysis', 'Social energy patterns'],
    complexity: 2.8,
    uniqueness: 1.9
  };
}